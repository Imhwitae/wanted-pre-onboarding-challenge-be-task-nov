#### Q. 동시에 같은 `DB Table row`를 업데이트 하는 상황을 방어하기 위해 어떻게 개발하실 건지 설명해주세요.   
먼저 왜 이런 문제가 생기는지 알아보겠습니다.   

예를 들어, 만약 어느 쇼핑몰에서 100개 한정 판매 물품이 있다고 할 때, 99개의 물건이 팔린 상태에서 유저 2명이 동시에 1개씩 물건을 구입했습니다. 이렇게 되면 두 개의 요청이 한 번에 들어가면서 유저 2명에서 주문 성공!이 되면서 100개에서 끝나야할 한정 판매가 101개로 늘어나는 상황이 생길 수 있습니다.   

이제 이러한 불상사를 막기 위한 해결책을 알아보겠습니다.   

**DB Lock 사용하기**   
Lock이란, 트랜잭션 처리의 순차성을 보장하기 위한 방법으로 DB마다 Lock을 구현하는 방식이 다를 수 있습니다.   
Lock은 상황에 따라 두 가지로 나눌 수 있습니다.   

1. **Shared Lock(Read Lock)**   
	보통 데이터를 읽을 때 사용합니다. 원하는 데이터에 Lock을 걸어도 다른 곳에서 읽을 수 있습니다.   
	즉, 내가 보고 있는 데이터는 다른 사용자가 볼 수 있지만 변경할 수는 없습니다.   
	또한 Exclusive Lock을 설정할 수 없습니다.

2. **Exclusive Lock(Write Lock)**  
	보통 데이터를 변경할 때 사용합니다. Lock이 해제되기 전 까지는 Shared Lock, Exclusive Lock을 설정할 수 없습니다. 즉 읽기와 쓰기가 불가능합니다.

Lock을 사용할 때 주의할 점이 있는데 바로 **Dead Lock** 현상입니다.   

**Dead Lock?**   
Dead Lock은 트랜잭션간의 교착상태로, 두 개의 트랜잭션 간에 각각의 트랜잭션이 가지고 있는 리소스의 Lock을 획득하려고 할 때 발생합니다. 예를 들자면, 
```
Transaction1) START TRANSACTION; insert into A values(1);
Transaction2) START TRANSACTION; insert into B values(1);
```
으로 서로 Lock을 획득해주고 commit은 하지 않습니다. 그 상태에서 
```
Transaction1) START TRANSACTION; insert into B values(1);
Transaction2) START TRANSACTION; insert into A values(1);
```
으로 서로의 행에 대한 Lock을 획득하려고 하면, 맨 처음 실행했던 트랜잭션이 끝날 때 까지 두 번째 트랜잭션은 무한정 대기하게 됩니다. 이 때 Dead Lock이 생기게 됩니다.   

이런 Dead Lock을 해결하는 방법을 알아보겠습니다.   

1. **예방 기법**
	- 각 트랜잭션이 실행되기 전에 필요한 모든 자원을 Lock합니다.   
		(이 방식은 필요한 모든 데이터를 Lock하기 때문에 병행성이 떨어짐)
	- `set lock_timeout` 명령어를 통해 일정시간이 지나면 쿼리를 취소합니다.   
		(기존 교착상태가 있는 상태면 다시 들어오는 쿼리만 취소하기 때문에 근본적인 해결책이 될 수 없음)
2. **회피 기법**   
	회피 기법은 자원을 할당할 때 Time Stamp를 활용해서 교착상태가 일어나지 않게 하는 방법입니다.
	1. Wait-Die 방식   
		트랜잭션 A와 트랜잭션 C가 트랜잭션 B로 인해 잠금된 데이터를 접근할 때 트랜잭션 A의 Time Stamp가 더 높다면 트랜잭션 A는 대기(Wait)하게 되고, 트랜잭션 A보다 Time Stamp가 낮은 트랜잭션 C는 포기(Die)하게 됩니다.
	2. Wound-Wait 방식   
		다른 트랜잭션이 데이터를 점유하고 있을 때 빼앗거나(Wound) 기다리는(Wait) 방식입니다.   
		위와 같은 Time Stamp를 가진 트랜잭션 A, C가 트랜잭션 B가 점유한 상태에서 접근할 때 트랜잭션 A의 우선순위가 더 높으므로 선점(Wound)하고 트랜잭션 C는 대기(Wait)하게 됩니다.
3. **낙관적 병행 기법**   
	낙관적 병행 기법은 트랜잭션이 실행되는 동안에는 검사를 수행하지 않고, 커밋된 후에 문제가 있다면 롤백하는 기법입니다.   
		이 기법은 '판독' -> '확인'-> '기록' 단계를 거치는데 '확인' 단계를 성공적으로 거친 트랜잭션만 '기록' 단계를 수행할 수 있습니다.
4. **빈도 줄이기**   
	- 트랜잭션을 자주 커밋하기
	- 정해진 순서대로 테이블 접근하기
	- 읽기 잠금 획득 `SELECT ~ FOR UPDATE`의 사용 피하기
	- 테이블 단위의 Lock을 획득해 갱신 직렬화
	- index 설계
